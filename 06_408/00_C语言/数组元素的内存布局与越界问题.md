---
tags:
  - 408_计算机学科专业基础
创建时间: 2026-02-15T23:56:00
考试科目: "408"
课程: C语言
阶段: 零基础
老师: 泥鳅
开始日期: 2026-02-15
结束日期: 2026-02-15
---
# 数组元素的内存布局与越界问题

> **知识回顾 —— 数组的性质**
> 1. 连续存储
> 2. 数据类型相同

## 数组元素的内存布局

- **数组的首地址**和**第一个元素 `arr[0]` 的地址**完全相同。
- 对于任意元素 `arr[i]`，其地址计算公式为：
  ```
  arr[i]的地址 = 数组首地址 + i * sizeof(元素类型)
  ```
  因此，要访问某个元素，只需要知道数组的首地址、下标和元素类型即可，**无需知道数组的长度**。

## `[]` 的本质

- 在定义语句中（如 `int arr[5];`），`[]` 是数组定义运算符，用于指定数组的长度。
- 在非定义语句中（如 `arr[i] = 10;`），`[]` 是下标运算符，其本质是**先计算地址，再访问元素**：
  1. 根据数组名（首地址）、下标 `i` 和元素类型计算出第 `i` 号元素的地址。
  2. 对该地址进行读写操作。

---

## 示例1：正常访问数组

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    for (int i = 0; i < 5; ++i) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    printf("-------------------------\n");
    
    arr[3] = 1024;                // 修改合法元素
    for (int i = 0; i < 5; ++i) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    return 0;
}
```

**输出：**
```
arr[0] = 1
arr[1] = 2
arr[2] = 3
arr[3] = 4
arr[4] = 5
-------------------------
arr[0] = 1
arr[1] = 2
arr[2] = 3
arr[3] = 1024
arr[4] = 5
```

## 示例2：数组越界访问的危害

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int a = 20;                       // 局部变量，位于栈上
    for (int i = 0; i < 13; ++i) {    // 越界循环，访问下标0~12
        arr[i] = i + 1;
    }
    printf("a = %d\n", a);            // 预期20，实际输出12
    return 0;
}
```

**输出结果：**
```
a = 12
```

### 原因分析

- 数组 `arr` 长度为 5，合法下标为 0 ~ 4。循环中当 `i >= 5` 时，写入的内存已超出 `arr` 的范围，属于**越界写**。
- 局部变量 `arr` 和 `a` 都分配在**栈**上，它们在内存中的位置是相邻的（具体顺序由编译器决定）。越界写入会覆盖相邻内存区域。
- 在该运行结果中，`a` 的值从 20 变为 12，说明变量 `a` 恰好位于数组 `arr` 之后（地址更高或更低，取决于编译器），且 `&a` 与 `&arr[11]` 相同。
  - `i = 5 ~ 10` 的写入覆盖了其他无关内存（可能是填充、其他局部变量或调用信息）。
  - `i = 11` 时，向 `arr[11]` 写入值 `12`，而该地址正好是 `a` 的地址，因此 `a` 被改为 `12`。
  - 之后的 `i = 12` 写入到 `a` 之后的地址，不再影响 `a`。

### 重要提示

- **数组越界属于未定义行为（Undefined Behavior）**：其结果完全依赖于编译器的栈布局、优化选项等因素。不同的编译器或编译选项可能产生不同结果（程序崩溃、其他变量被修改、甚至正常运行但隐藏 bug）。
- **调试建议**：始终确保数组下标在合法范围内，使用宏或常量定义数组长度，并严格检查循环边界。

---

## 总结

| 数组类型         | 内存分配者   | 分配位置     | 生命周期                 |
|------------------|--------------|--------------|--------------------------|
| 局部数组         | 编译器（栈） | 栈区         | 函数执行期间             |
| 全局/静态数组    | 编译器       | 静态存储区   | 整个程序运行期间         |
| 动态数组（malloc等）| 程序员     | 堆区         | 手动分配，手动释放       |

- **下标运算符 `[]` 的本质**：计算地址 → 访问内存。
- **越界后果**：可能破坏相邻变量数据，导致逻辑错误或崩溃，且难以调试。
- **最佳实践**：始终警惕数组边界，使用安全循环（如 `i < 数组长度`），避免依赖未定义行为。