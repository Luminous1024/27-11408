---
tags:
  - 408_计算机学科专业基础
创建时间: 2026-02-14T22:30:00
考试科目: "408"
课程: C语言
阶段: 零基础
老师: 泥鳅
开始日期: 2026-02-14
结束日期: 2026-02-14
---
# C语言数组声明详解：`int arr[5]`

在C语言中，当你写下 `int arr[5];` 时，编译器会在内存中为你分配一段连续的存储空间，足以容纳5个 `int` 类型的值。这篇笔记将详细解释这一过程，包括内存布局、地址表示、数组名的含义以及常见陷阱。

---

## 1. 内存分配的基本事实

- **每个 `int` 占用 4 字节**（在32位系统上通常是这个大小，具体由编译器和平台决定）。
- **数组的5个元素在内存中连续存放**，相邻元素地址相差 `sizeof(int)` 字节（即4字节）。
- **数组名 `arr` 是一个常量指针**，它保存了数组首元素的地址（即 `&arr[0]`），且该地址不能修改（不能做 `arr++` 操作）。
- **数组占用的总字节数** = `5 * sizeof(int)` = 20 字节。
- **数组的存储位置**取决于定义的位置：
  - 如果定义在函数内部（局部变量），数组分配在**栈**上。
  - 如果定义在函数外部（全局变量）或使用 `static` 修饰，数组分配在**静态存储区**（通常初始化为0）。

---

## 2. 实际内存地址表示

在32位系统中，内存地址是一个32位的无符号整数，通常用8位十六进制数表示（如 `0x7ffe1234`）。下面假设数组 `arr` 是一个局部变量，被分配在栈上，起始地址为 `0x7ffe1234`。

### 内存布局图（ASCII艺术版）

```
内存地址（十六进制）   →   0x7ffe1234      0x7ffe1238      0x7ffe123c      0x7ffe1240      0x7ffe1244
                    ├───────────────┼───────────────┼───────────────┼───────────────┼───────────────┤
变量名（元素）        │    arr[0]     │    arr[1]     │    arr[2]     │    arr[3]     │    arr[4]     │
                    ├───────────────┼───────────────┼───────────────┼───────────────┼───────────────┤
存储的值（未初始化）   │   不确定值    │   不确定值    │   不确定值    │   不确定值    │   不确定值    │
                    ├───────────────┼───────────────┼───────────────┼───────────────┼───────────────┤
指针关系            ↑
                 arr == &arr[0] = 0x7ffe1234
```

- 每个格子宽度代表4字节（一个 `int` 的存储单元）。
- 相邻元素的地址差为4字节（十六进制表示为 `0x4`）。
- 由于是局部变量且未初始化，每个元素的值是栈上原有的“垃圾值”。

---

## 3. 数组名的深层含义

- **`arr`** 本身是一个表达式，在大多数上下文中（例如传递给函数、参与运算），它会被自动转换为指向其首元素的指针，类型为 `int*`。所以 `arr` 等价于 `&arr[0]`。
- **例外情况**：
  - 当 `arr` 作为 `sizeof` 的操作数时，`sizeof(arr)` 返回整个数组的大小（20字节）。
  - 当 `arr` 作为 `&` 的操作数时，`&arr` 得到的是指向整个数组的指针，类型为 `int (*)[5]`，其值与 `arr` 相同（都是数组首地址），但指针类型不同。

### 示例代码

```c
#include <stdio.h>

int main() {
    int arr[5];  // 未初始化，包含垃圾值

    printf("数组首地址：%p\n", (void*)arr);
    printf("首元素地址：%p\n", (void*)&arr[0]);
    printf("数组整体地址：%p\n", (void*)&arr);

    printf("数组大小：%zu 字节\n", sizeof(arr));       // 20
    printf("每个int大小：%zu 字节\n", sizeof(int));     // 4

    // 验证元素连续存放
    for (int i = 0; i < 5; i++) {
        printf("&arr[%d] = %p\n", i, (void*)&arr[i]);
    }
    return 0;
}
```

**可能的输出**（地址值每次运行可能不同）：
```
数组首地址：0x7ffe1234
首元素地址：0x7ffe1234
数组整体地址：0x7ffe1234
数组大小：20 字节
每个int大小：4 字节
&arr[0] = 0x7ffe1234
&arr[1] = 0x7ffe1238
&arr[2] = 0x7ffe123c
&arr[3] = 0x7ffe1240
&arr[4] = 0x7ffe1244
```

可以看到，`arr`、`&arr[0]`、`&arr` 的值完全相同，但前两者类型为 `int*`，后者为 `int (*)[5]`。

---

## 4. 元素访问的底层原理

- 访问 `arr[i]` 等价于 `*(arr + i)`。编译器会计算 `arr + i * sizeof(int)` 得到第 `i` 个元素的地址，然后取出该地址处的值。
- 例如，`arr[2]` 的地址 = `0x7ffe1234 + 2 * 4 = 0x7ffe123c`。

---

## 5. 未初始化的陷阱

- 如果 `arr` 是局部变量（自动存储期），其元素的值是不确定的（可能是之前栈帧留下的数据）。**使用前必须显式初始化**，否则会导致未定义行为。
- 如果 `arr` 是全局变量或静态局部变量，则会被自动初始化为0（所有字节清零）。

---

## 6. 边界检查

- C语言**不进行数组下标越界检查**。如果你访问 `arr[5]`，编译器会尝试计算地址 `0x7ffe1234 + 5*4 = 0x7ffe1248`，然后读写该地址上的内存。这个地址可能属于其他变量或无效区域，导致数据损坏或程序崩溃。**这是C语言中常见的安全漏洞，必须由程序员自己保证下标不越界**。

---

## 7. 总结

- `int arr[5];` 声明在内存中创建了一个包含5个连续 `int` 元素的数组。
- 数组名 `arr` 是指向首元素的常量指针，但 `sizeof(arr)` 能获得整个数组的大小。
- 内存地址是真实的、与系统位数匹配的十六进制数，相邻元素地址相差 `sizeof(int)` 字节。
- 使用前务必初始化局部数组，并警惕越界访问。

---

## 8. 补充说明：为什么不用简化的四位十六进制地址？

四位十六进制数（如 `0x1000`）只能表示16位地址，仅适用于16位系统或教学演示中的**相对偏移**。在真实的32位/64位系统中，内存地址必须用8位或16位十六进制数表示。例如：
- 32位地址范围：`0x00000000` ~ `0xFFFFFFFF`
- 64位地址范围：`0x0000000000000000` ~ `0xFFFFFFFFFFFFFFFF`

使用实际宽度的地址，能更准确地反映计算机硬件的工作方式，避免对地址空间的误解。

---

**标签**： #C语言 #数组 #内存管理 #指针