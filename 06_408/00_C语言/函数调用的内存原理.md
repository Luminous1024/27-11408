---
tags:
  - 408_计算机学科专业基础
考试科目: "408"
创建时间: 2026-02-10T19:50:00
课程: C语言
阶段: 零基础
老师: 泥鳅
开始日期: 2026-02-10
结束日期: 2026-02-10
---
# 函数调用的内存原理（栈帧详解）

## 一、**核心概念：栈帧（Stack Frame）**
每个函数调用都会在栈上创建一个**栈帧**，包含：
- 函数参数
- 返回地址
- 局部变量
- 保存的寄存器值

## 二、**函数调用过程**

### **1. 调用前准备**
```c
int add(int a, int b) {
    int result = a + b;
    return result;
}

int main() {
    int x = 5, y = 3;
    int sum = add(x, y);  // 函数调用
    return 0;
}
```

### **2. 栈帧结构示意图**
```
高地址
┌─────────────────┐
│  main()栈帧     │
│  - 返回地址     │ ← main函数返回给操作系统的地方
│  - 旧的ebp      │
│  - 局部变量     │
├─────────────────┤ ← 栈增长方向（向下）
│  add()栈帧      │
│  - 返回地址     │ ← add返回后回到main的地址
│  - 旧的ebp      │ ← 保存main的栈帧基址
│  - 参数a(5)     │
│  - 参数b(3)     │
│  - 局部变量result│
├─────────────────┤ ← ESP（栈顶指针）
│                 │
└─────────────────┘
低地址
```

## 三、**详细步骤（x86-64为例）**

### **步骤1：调用函数前**
```assembly
# main函数中调用add(x, y)
mov    edi, 5        # 第一个参数x=5（64位下常用寄存器传参）
mov    esi, 3        # 第二个参数y=3
call   add           # 1. 将下一条指令地址（返回地址）压栈
                     # 2. 跳转到add函数
```

### **步骤2：进入被调用函数（prologue）**
```assembly
add:
    push   rbp           # 保存旧的栈帧基址
    mov    rbp, rsp      # 设置新的栈帧基址
    sub    rsp, 16       # 为局部变量分配栈空间
```

### **步骤3：函数内部执行**
```assembly
    mov    DWORD PTR [rbp-4], edi   # 存储参数a到栈帧
    mov    DWORD PTR [rbp-8], esi   # 存储参数b到栈帧
    mov    edx, DWORD PTR [rbp-4]   # 读取a
    add    edx, DWORD PTR [rbp-8]   # a + b
    mov    DWORD PTR [rbp-12], edx  # 存储result到栈帧
    mov    eax, DWORD PTR [rbp-12]  # 将返回值放入eax
```

### **步骤4：函数返回（epilogue）**
```assembly
    mov    rsp, rbp      # 恢复栈指针（释放局部变量空间）
    pop    rbp           # 恢复旧的栈帧基址
    ret                  # 1. 弹出返回地址
                         # 2. 跳转到返回地址
```

## 四、**关键寄存器的作用**

| 寄存器 | 名称 | 作用 |
|--------|------|------|
| **RSP** | 栈指针寄存器 | 指向栈顶位置 |
| **RBP** | 栈帧基址寄存器 | 指向当前栈帧基址 |
| **RIP** | 指令指针寄存器 | 指向下一条要执行的指令 |

## 五、**栈帧布局详解**

```
高地址
┌─────────────────┐
│   调用者栈帧    │
├─────────────────┤ ← 调用前的RBP
│   返回地址      │ ← 调用call时压入
├─────────────────┤ ← 新的RBP（被调用函数的RBP）
│   保存的RBP     │ ← push rbp压入
├─────────────────┤
│   局部变量3     │
│   局部变量2     │
│   局部变量1     │
├─────────────────┤ ← RSP（栈顶）
│                 │
└─────────────────┘
低地址
```

## 六、**参数传递方式**

### **1. 寄存器传参（现代常用）**
- x86-64 Linux：RDI, RSI, RDX, RCX, R8, R9
- x86-64 Windows：RCX, RDX, R8, R9
- 多余参数通过栈传递

### **2. 栈传参（传统x86）**
```assembly
push   3      # 先压入第二个参数
push   5      # 再压入第一个参数
call   add
add    esp, 8 # 清理栈上参数
```

## 七、**递归调用的栈原理**

```c
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);  // 递归调用
}
```

### **递归栈帧示意图**
```
高地址
┌─────────────────┐
│ factorial(5)    │ ← 第一层调用
├─────────────────┤
│ factorial(4)    │ ← 第二层调用
├─────────────────┤
│ factorial(3)    │ ← 第三层调用
├─────────────────┤
│ factorial(2)    │ ← 第四层调用
├─────────────────┤
│ factorial(1)    │ ← 第五层调用（基线条件）
├─────────────────┤ ← RSP
│                 │
└─────────────────┘
低地址
```

## 八、**栈溢出（Stack Overflow）**

### **原因**：
1. 递归深度过大
2. 局部数组/变量过大
3. 无限递归

### **示例**：
```c
void infinite_recursion() {
    char large_array[1024*1024];  // 1MB局部数组
    infinite_recursion();         // 无限递归
}
```

## 九、**调用约定（Calling Convention）**

| 约定 | 参数传递 | 栈清理 | 返回值 | 典型系统 |
|------|----------|--------|--------|----------|
| **cdecl** | 从右到左压栈 | 调用者 | EAX | x86 Linux C |
| **stdcall** | 从右到左压栈 | 被调用者 | EAX | Windows API |
| **fastcall** | 部分寄存器 | 混合 | EAX | 优化调用 |
| **System V AMD64** | 寄存器优先 | 调用者 | RAX/EAX | x86-64 Linux/Unix |

## 十、**实际调试观察**

### **GDB调试示例**：
```bash
# 编译时添加调试信息
gcc -g program.c -o program

# 使用GDB调试
gdb program

# 设置断点
(gdb) break main
(gdb) break add

# 运行程序
(gdb) run

# 查看栈帧信息
(gdb) backtrace      # 显示调用栈
(gdb) info frame     # 查看当前栈帧
(gdb) info locals    # 查看局部变量
(gdb) info args      # 查看参数

# 查看寄存器
(gdb) info registers
```

## 十一、**关键要点总结**

1. **栈帧创建**：每个函数调用都创建一个栈帧
2. **栈指针移动**：RSP指向栈顶，RBP指向栈帧基址
3. **参数传递**：现代系统优先使用寄存器，传统用栈
4. **返回机制**：返回地址保存在栈中，`ret`指令用于返回
5. **递归本质**：每次递归调用创建新的栈帧
6. **栈溢出**：栈空间耗尽导致程序崩溃
7. **调试工具**：GDB可以查看调用栈和栈帧信息

理解函数调用的内存原理对于调试、优化和理解程序行为至关重要，尤其是在处理递归、缓冲区溢出和性能优化时。