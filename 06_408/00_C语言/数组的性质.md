---
tags:
  - 408_计算机学科专业基础
创建时间: 2026-02-14T22:35:00
考试科目: "408"
课程: C语言
阶段: 零基础
老师: 泥鳅
开始日期: 2026-02-14
结束日期: 2026-02-14
---
# C语言数组的性质

数组是C语言中最基础的数据结构之一，它提供了一种将相同类型的多个数据项组织在一起并连续存储的方式。理解数组的性质对于正确、高效地使用它们至关重要。本篇笔记系统地总结了C语言数组的核心性质。

---

## 1. 连续存储
- 数组的所有元素在内存中**连续存放**，相邻元素之间没有空隙。
- 第 `i` 个元素的地址 = 数组首地址 + `i * sizeof(元素类型)`。
- 这种连续性使得数组支持高效的随机访问（通过下标直接计算地址）。

```c
int a[5] = {10, 20, 30, 40, 50};
// 假设 a[0] 地址为 0x1000，则：
// a[1] 地址为 0x1004，a[2] 地址为 0x1008，依此类推（假设 int 占4字节）
```

---

## 2. 固定大小
- 数组的大小在**编译时确定**（除非使用变长数组，VLA，但VLA也是运行时确定一次，之后不可变）。
- 不能动态增加或减少数组的长度（如需动态大小，应使用动态内存分配 `malloc`/`calloc`）。
- 可以通过 `sizeof` 运算符获取整个数组占用的字节数：`sizeof(arr)`。
- 数组中元素个数 = `sizeof(arr) / sizeof(arr[0])`。

---

## 3. 下标访问
- 数组元素通过下标（索引）访问，下标（索引）从 **0** 开始。
- 元素的下标（索引）是有序的。
- 形式为 `arr[index]`，其中 `index` 可以是整数常量、变量或表达式。
- 编译器将 `arr[i]` 转换为 `*(arr + i)`，即首地址加上偏移量后解引用。

```c
int arr[5];
arr[0] = 1;   // 第一个元素
arr[4] = 5;   // 最后一个元素
```

---

## 4. 数组名与指针的关系
- 在大多数表达式中，**数组名会被隐式转换为指向其首元素的指针**（类型为 `元素类型*`）。
- 例外情况：
  - 作为 `sizeof` 的操作数时，返回整个数组的大小。
  - 作为 `&` 的操作数时，得到指向整个数组的指针（类型为 `数组类型*`）。
  - 作为字符串字面量初始化字符数组时。
- 数组名本身是常量（不能作为左值修改），即不能执行 `arr++` 或 `arr = ...` 等操作。

```c
int arr[5];
int *p = arr;      // 等价于 p = &arr[0]
printf("%zu\n", sizeof(arr));  // 输出整个数组字节数，如20
printf("%p\n", &arr);          // 输出数组地址，与arr相同但类型不同
```

---

## 5. 元素类型相同
- 数组中所有元素必须是**相同的数据类型**（或至少兼容的类型）。
- 每个元素占用的内存大小相同，由元素类型决定。
- 这一性质保证了可以通过统一的步长计算地址。

---

## 6. 数组的地址
- 数组的首地址（即第一个元素的地址）可以用 `arr` 或 `&arr[0]` 表示。
- `&arr` 表示整个数组的地址，虽然数值上与 `arr` 相同，但指针类型不同（`int (*)[5]` vs `int*`），因此 `&arr + 1` 会跳过整个数组的大小（如20字节），而 `arr + 1` 只跳过一个元素（4字节）。

```c
int arr[5];
printf("arr = %p\n", (void*)arr);
printf("arr+1 = %p\n", (void*)(arr+1));     // 增加4字节
printf("&arr = %p\n", (void*)&arr);
printf("&arr+1 = %p\n", (void*)(&arr+1));   // 增加20字节
```

---

## 7. 无边界检查
- C语言**不进行数组下标越界检查**。
- 访问 `arr[i]` 时，只要 `i` 使得地址落在进程的地址空间内，程序就会尝试读写该内存。这可能导致：
  - 读取到其他变量的数据。
  - 修改其他变量或程序状态。
  - 段错误（若地址无效）。
- 程序员必须自己确保下标在 `[0, N-1]` 范围内。

```c
int arr[5];
arr[5] = 100;   // 越界访问，未定义行为
```

---

## 8. 存储期
数组的存储期由其定义位置决定：

- **静态存储期**：全局数组或 `static` 修饰的局部数组。在程序启动时分配，程序结束时释放。未显式初始化时，元素自动初始化为0。
- **自动存储期**：普通局部数组（在函数内部定义）。在进入块时分配，退出块时释放。未初始化时，元素值为不确定（垃圾值）。
- **动态存储期**：通过 `malloc` 等分配的数组。由程序员手动管理生命周期。

---

## 9. 初始化规则
- 可以在定义时初始化，例如 `int arr[5] = {1, 2, 3, 4, 5};`
- 如果提供的初始化值少于数组长度，剩余元素被初始化为0（对于静态存储期）或0（对于自动存储期？实际上自动存储期也会被初始化为0，但仅限于部分初始化的情况：C99起，如果初始化列表部分提供，剩余元素自动初始化为0，无论存储期）。
  - 对于自动存储期数组，`int arr[5] = {1, 2};` 等价于 `{1, 2, 0, 0, 0}`。
- 如果完全不初始化，静态存储期数组默认初始化为0，自动存储期数组元素值不确定。
- 可以省略数组长度，由编译器根据初始化列表推断：`int arr[] = {1, 2, 3};` 此时数组长度为3。

---

## 10. 多维数组
- 多维数组本质上是**数组的数组**。例如 `int matrix[3][4]` 是一个包含3个元素的数组，每个元素是一个包含4个 `int` 的数组。
- 存储顺序为**行优先**（row-major order），即先存储第一行的所有元素，接着第二行，以此类推。
- 访问元素 `matrix[i][j]` 等价于 `*(*(matrix + i) + j)`。

```c
int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
// 内存布局：1 2 3 4 5 6 连续存放
```

---

## 11. 数组作为函数参数
- 当数组作为函数参数时，它会被**自动转换为指针**，指向其首元素。因此，在函数内部无法通过 `sizeof` 获得整个数组的大小。
- 通常需要额外传递数组长度。

```c
void func(int arr[], int n) {
    // arr 实际上是指针，sizeof(arr) 是指针大小，不是数组大小
}
```

---

## 12. 数组与字符串
- 字符串在C语言中用字符数组表示，以空字符 `'\0'` 结尾。
- 字符数组可以用字符串字面量初始化，如 `char str[] = "hello";` 会自动添加 `'\0'`，数组长度为6。

---

## 总结
C语言数组是一种简单而强大的数据结构，具有连续存储、固定大小、下标访问、数组名与指针的紧密关系等核心性质。理解这些性质是编写安全、高效C代码的基础。特别要注意的是数组越界、指针转换以及数组作为参数时的退化行为，这些都是C语言程序员必须时刻警惕的陷阱。

---

**标签**： #C语言 #数组 #内存管理 #指针