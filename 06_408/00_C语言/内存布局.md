---
tags:
  - 408_计算机学科专业基础
考试科目: "408"
创建时间: 2026-02-10T19:45:00
课程: C语言
阶段: 零基础
老师: 泥鳅
开始日期: 2026-02-10
结束日期: 2026-02-10
---
# 简化版计算机内存布局

## 一、**核心划分**

```
高地址
┌─────────────────┐
│     内核区      │ ← 操作系统专用，用户程序无法直接访问
├─────────────────┤ ← 用户区与内核区分界线
│                 │
│     用户区      │ ← 每个程序有自己独立的虚拟空间
│                 │
└─────────────────┘
低地址
```

## 二、**用户区内部布局（从低到高）**

### **1. 代码段（只读）**
- **存放什么**：程序的可执行指令
- **特点**：只读、可被多个进程共享
- **示例**：`int main() { return 0; }` 编译后的机器码

### **2. 数据段**
- **已初始化数据**：全局变量、静态变量（有初始值）
  ```c
  int global_var = 100;  // 存储在这里
  ```
- **未初始化数据（BSS段）**：全局变量、静态变量（无初始值，启动时自动清零）
  ```c
  int uninitialized_var;  // 存储在这里，默认为0
  ```

### **3. 堆（动态内存区）**
- **存放什么**：`malloc()`, `new` 等动态分配的内存
- **特点**：手动申请/释放，向高地址增长
- **生命周期**：程序运行期间
- **示例**：
  ```c
  int *p = malloc(100);  // 分配在堆上
  ```

### **4. 栈（自动内存区）**
- **存放什么**：局部变量、函数参数、返回地址
- **特点**：自动分配/释放，向低地址增长
- **生命周期**：函数调用期间
- **示例**：
  ```c
  void func() {
      int local_var = 10;  // 分配在栈上
  }
  ```

## 三、**直观示意图**

```
高地址
┌─────────────────┐
│     内核区      │ ← 操作系统专用
├─────────────────┤
│     栈区        │ ← 向下增长（高→低）
│    ↓            │
├─────────────────┤
│     堆区        │ ← 向上增长（低→高）
│    ↑            │
├─────────────────┤
│    数据段       │ ← 全局/静态变量
├─────────────────┤
│    代码段       │ ← 程序指令（只读）
└─────────────────┘
低地址
```

## 四、**各区域关键特性对比**

| 区域 | 存储内容 | 分配方式 | 增长方向 | 管理方式 |
|------|----------|----------|----------|----------|
| **代码段** | 程序指令 | 编译时确定 | - | 操作系统 |
| **数据段** | 全局/静态变量 | 编译时确定 | - | 操作系统 |
| **堆** | 动态分配内存 | 运行时`malloc/new` | 向上 | 程序员手动 |
| **栈** | 局部变量、函数调用 | 运行时自动 | 向下 | 编译器自动 |
| **内核区** | 操作系统代码 | 系统启动时 | - | 操作系统 |

## 五、**简单记忆口诀**

1. **"代码-数据-堆-栈-内核"**（从低到高）
2. **堆向上长，栈向下压**
3. **代码只读，数据可写**
4. **堆要手动管，栈会自动清**

## 六、**实际编程示例**

```c
#include <stdlib.h>

int global_init = 10;        // 数据段（已初始化）
int global_uninit;           // 数据段（BSS段，未初始化）

int main() {
    static int static_var = 20;  // 数据段
    int local_var = 30;          // 栈上
    int *heap_var = malloc(sizeof(int));  // 堆上
    *heap_var = 40;
    
    free(heap_var);  // 必须手动释放堆内存
    return 0;        // 栈内存自动释放
}
```

## 七、**重要提示**

1. **栈溢出**：递归过深或局部变量过大导致
2. **内存泄漏**：堆内存分配后忘记释放
3. **段错误**：访问非法内存区域（如代码段写操作）
4. **每个进程有独立的用户区**，但共享内核区

这个简化版涵盖了95%的日常编程场景，足够理解大多数内存相关问题。